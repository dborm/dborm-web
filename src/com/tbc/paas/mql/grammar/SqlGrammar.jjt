 /**
  * JavaCC file from SQL analyze(support Select and delete ).
  */options{  JDK_VERSION = "1.5";  IGNORE_CASE = true;  //  MULTI = true;
  TRACK_TOKENS = false;  BUILD_NODE_FILES = false;  NODE_PREFIX = "Sql";  NODE_FACTORY = "SqlNodeFactory";  NODE_CLASS = "SqlNode";  static = false;}PARSER_BEGIN(SqlGrammar)package com.tbc.paas.mql.grammar;import com.tbc.paas.mql.domain.SqlMetadata;import com.tbc.paas.mql.domain.SqlNode;import com.tbc.paas.mql.domain.SqlNodeFactory;import com.tbc.paas.mql.domain.SqlPhase;import com.tbc.paas.mql.domain.SqlColumn;import com.tbc.paas.mql.domain.SqlTable;@ SuppressWarnings({  "unused", "serial"}) public class SqlGrammar{  private int globalParameterCount = 0;  private int sliceIndex = 0;  private SqlPhase sqlPhase;  private SqlMetadata sqlMetadata = new SqlMetadata();  public SqlMetadata getSqlMetadata()  {    return this.sqlMetadata;  }  public SqlNode getRootNode()  {    return (SqlNode) jjtree.rootNode();  }  private void setSqlPhase(SqlPhase phase)  {    this.sqlPhase = phase;    sliceIndex = 0;  }}PARSER_END(SqlGrammar)SKIP :{  " "| "\r"| "\t"| "\n"}/**
 *Marks used in SQL,prefixed
 *with M_ to declare it is a mark.
 */TOKEN :{  < M_COMMA : "," >| < M_QUERY : "?" >| < M_L_BRACKET : "(" >| < M_R_BRACKET : ")" >| < M_EQUAL : "=" >| < M_ATTACH : "||" >| < M_GT : ">" >| < M_LT : "<" >| < M_EXCLAMATION : "!" >| < M_COLON : ":" >}TOKEN : /* SQL  Keywords, prefixed with K_ to avoid name clashes*/{  < K_ALL : "ALL" >| < K_AS : "AS" >| < K_SELECT : "SELECT" >| < K_DISTINCT : "DISTINCT" >| < K_DELETE : "DELETE" >| < K_AND : "AND" >| < K_OR : "OR" >| < K_FROM : "FROM" >| < K_WHERE : "WHERE" >| < K_COUNT : "COUNT" >| < K_MAX : "MAX" >| < K_MIN : "MIN" >| < K_SUM : "SUM" >| < K_AVG : "AVG" >| < K_LEFT : "LEFT" >| < K_RIGHT : "RIGHT" >| < K_INNER : "INNER" >| < K_FULL : "FULL" >| < K_OUTER : "OUTER" >| < K_JOIN : "JOIN" >| < K_ON : "ON" >| < K_UPDATE : "UPDATE" >| < K_SET : "SET" >| < K_INSERT : "INSERT" >| < K_INTO : "INTO" >| < K_VALUES : "VALUES" >| < K_NOT : "NOT" >| < K_NULL : "NULL" >| < K_BETWEEN : "BETWEEN" >| < K_DESC : "DESC" >| < K_ASC : "ASC" >| < K_EXISTS : "EXISTS" >| < K_GROUP : "GROUP" >| < K_HAVING : "HAVING" >| < K_IS : "IS" >| < K_ORDER : "ORDER" >| < K_BY : "BY" >| < K_LIKE : "LIKE" >| < K_IN : "IN" >| < K_LIMIT : "LIMIT" >| < K_OFFSET : "OFFSET " >| < K_TRUE : "TRUE" >| < K_FALSE : "FALSE" >}TOKEN : /* Numeric Constants */{  < S_NUMBER :    < FLOAT >  | < FLOAT >    (      [ "e", "E" ] ([ "-", "+" ])? < FLOAT >    )? >| < #FLOAT :    < INTEGER >  | < INTEGER > ("." < INTEGER >)?  | "." < INTEGER > >| < #INTEGER : (< DIGIT >)+ >| < #DIGIT : [ "0"-"9" ] >}TOKEN :{  < S_IDENTIFIER :    < IDENTIFIER >    (      "." (< IDENTIFIER >)    )? >| < #IDENTIFIER :    (< LETTER >)+    (      < DIGIT >    | < LETTER >    | < SPECIAL_CHARS >    )* >| < #LETTER : [ "a"-"z", "A"-"Z" ] >| < #SPECIAL_CHARS :    "$"  | "_" >| < S_VALUE : "'" (~[ "'" ])* "'" >}void analyze() #void :{}{  analyzeSelect()| analyzeDelete()| analyzeUpdate()| analyzeInsert()}//Analyze Delete Sql
void analyzeDelete() #Delete :{  Token t;}{  < K_DELETE > < K_FROM > t = < S_IDENTIFIER >  {    jjtThis.jjtSetValue(t.image);    SqlTable sqlTable = new SqlTable(t.image);    sqlMetadata.addTable(sqlTable);  }  [ analyzeWhereSegment() ]}void analyzeUpdate() #Update :{  Token t;  sqlPhase = SqlPhase.UPDATE;}{  < K_UPDATE > t = < S_IDENTIFIER > < K_SET > analyzeUpdateColumns()  [    < K_WHERE >    {      sqlPhase = SqlPhase.WHERE;    }    analyzeCondition() #Where  ]  {    SqlTable sqlTable = new SqlTable(t.image);    sqlMetadata.addTable(sqlTable);  }}void analyzeUpdateColumns() #UpdateColumns :{}{  analyzeUpdateColumn()  (    < M_COMMA > analyzeUpdateColumn()  )*}void analyzeUpdateColumn() #UpdateColumn :{}{  analyzeColumnName() < M_EQUAL >  (    ananayzeValuePostion() [ analyzeArithmeticOperators() analyzeColumnName() ]  |    (      analyzeColumnName() analyzeArithmeticOperators() ananayzeValuePostion()    )  )}void analyzeArithmeticOperators() #ArithmeticOperator :{  Token t;}{  (    t = "+"  | t = "-"  | t = "*"  | t = "/"  )  {    jjtThis.jjtSetValue(t.image);  }}void analyzeInsert() #Insert :{  Token t;}{  < K_INSERT > < K_INTO > t = < S_IDENTIFIER >  {    sqlPhase = SqlPhase.INSERT;    sliceIndex = 0;  }  [ analyzeInsertColumns() ] analyzeValues()  {    SqlTable sqlTable = new SqlTable(t.image);    sqlMetadata.addTable(sqlTable);  }}void analyzeInsertColumns() #Columns :{}{  < M_L_BRACKET > analyzeColumnName()  (    {      sliceIndex++;    }    < M_COMMA > analyzeColumnName()  )*  < M_R_BRACKET >}void analyzeValues() #Values :{}{  < K_VALUES > < M_L_BRACKET > ananayzeValuePostion()  (    < M_COMMA > ananayzeValuePostion()  )*  < M_R_BRACKET >}void analyzeSelect() #Select :{}{  < K_SELECT > analyzeColumnSegment() analyzeFromSegment() [ analyzeWhereSegment() ] [ analyzeGroupSegment() ] [ analyzeOrderSegment() ] [ analyzeLimitSegment() ]}void analyzeLimitSegment() #LimitSegment :{}{  (    analyzeLimit() [ analyzeOffset() ]  )|  (    analyzeOffset() [ analyzeLimit() ]  )}void analyzeLimit() #LIMIT :{}{  < K_LIMIT > ananayzeValuePostion()}void analyzeOffset() #OFFSET :{}{  < K_OFFSET > ananayzeValuePostion()}void analyzeColumnSegment() #ColumnSegment :{  sqlPhase = SqlPhase.SELECT;  sliceIndex = 0;}{  [    < K_DISTINCT > #Distinct  | < K_ALL >  ]  (analyzeColumn() (< M_COMMA > analyzeColumn()) *)}void analyzeFromSegment() #FromSegment :{  sqlPhase = SqlPhase.FROM;  sliceIndex = 0;}{  < K_FROM > analyzeTable()  (    {      sliceIndex++;    }    < M_COMMA > analyzeTable()  )*}void analyzeWhereSegment() #WhereSegment :{  sqlPhase = SqlPhase.WHERE;  sliceIndex = 0;}{  < K_WHERE > analyzeCondition()}void analyzeColumn() #Column :{}{  (    analyzeColumnName()  | analyzeAggregationFunction()  )  [ analyzeAlias() ]}void analyJoin() #Join :{  String join;}{  (    < K_LEFT > [ < K_OUTER > ] < K_JOIN >    {      join = " LEFT JOIN ";    }  | < K_RIGHT > [ < K_OUTER > ] < K_JOIN >    {      join = " RIGHT JOIN ";    }  | < K_FULL > [ < K_OUTER > ] < K_JOIN >    {      join = " FULL JOIN ";    }  | [ < K_INNER > ] < K_JOIN >    {      join = " INNER JOIN ";    }  )  analyzeTable() < K_ON > analyzeCondition() #JoinCondition  {    jjtThis.jjtSetValue(join);  }}void analyzeTable() #Table :{  Token t;  String tableAlias = null;}{  t = < S_IDENTIFIER > [ tableAlias = analyzeTableAlias() ]  {    SqlTable sqlTable = new SqlTable(t.image, tableAlias, sliceIndex);    sqlMetadata.addTable(sqlTable);    jjtThis.jjtSetValue(sqlTable);  }  (    analyJoin()  )*}void analyzeNullOperator() #Null :{}{  < K_IS >  [    < K_NOT >    {      jjtThis.jjtSetValue(true);    }  ]  < K_NULL >}void analyzeInOrLikeOperator() #void :{}{  [ < K_NOT > #Not ] (analyzeIn()| analyzeLike())}void analyzeIn() #In :{}{  < K_IN > < M_L_BRACKET > ananayzeValuePostion()  (    < M_COMMA > ananayzeValuePostion()  )*  < M_R_BRACKET >}void analyzeBinaryOperator() #BinaryOperator :{  Token first = null, second = null;}{  (    first = < M_EQUAL >  | first = < M_EXCLAMATION > second = < M_EQUAL >  | first = < M_GT > (second = < M_EQUAL >)?  | first = < M_LT >    (      second = < M_EQUAL >    | second = < M_GT >    )?  )  {    String operator = first.image;    if (second != null)    {      operator += second.image;    }    jjtThis.jjtSetValue(operator);  }}void analyzeGroupSegment() #GroupSegment :{  sqlPhase = SqlPhase.GROUP;  sliceIndex = 0;}{  < K_GROUP > < K_BY > analyzeColumnName()  (    < M_COMMA > analyzeColumnName()  )*  [ < K_HAVING > analyzeCondition() #Having ]}void analyzeCondition() #void :{}{  (    analyzeConditionSlice()  | < M_L_BRACKET > analyzeCondition() #BlockCondition(>1)  < M_R_BRACKET >)(  LOOKAHEAD(2)  (    < K_AND > #Add  | < K_OR > #Or)  analyzeCondition())*}void analyzeConditionSlice() #ConditionSlice :{}{  (    (      analyzeColumnName()    | analyzeAggregationFunction()    )    (      (        analyzeBinaryOperator()        (          analyzeColumnName()        | ananayzeValuePostion()        )      )    | analyzeInOrLikeOperator()    | analyzeNullOperator()    | analyBetweenOperator()    )  )|  (    ananayzeValuePostion() analyzeBinaryOperator()    (      analyzeColumnName()    | ananayzeValuePostion()    )  )}void analyzeLike() #Like :{}{  < K_LIKE > ananayzeValuePostion()}void analyBetweenOperator() #Between :{}{  < K_BETWEEN > ananayzeValuePostion() < K_AND > ananayzeValuePostion()}void analyzeOrderSegment() #OrderSegment :{  sqlPhase = SqlPhase.ORDER;  sliceIndex = 0;  Token t;}{  < K_ORDER > < K_BY > anaylyzeOrderSlice()  (    < M_COMMA > anaylyzeOrderSlice()  )*}private void anaylyzeOrderSlice() #void :{}{  (    analyzeColumnName()  | analyzeAggregationFunction()  )  [ analyzeOrder() ]}private void analyzeOrder() #Order :{  Token t;}{  (    t = < K_DESC >  | t = < K_ASC >  )  {    jjtThis.jjtSetValue(t.image.toUpperCase());  }}void analyzeAggregationFunction() #Aggregate :{  Token f;}{  (    f = < K_MAX >  | f = < K_MIN >  | f = < K_COUNT >  | f = < K_SUM >  | f = < K_AVG >  )  {    jjtThis.jjtSetValue(f.image);  }  < M_L_BRACKET >  (    analyzeColumnName()  | analyzeFunctionDistinct()  )  < M_R_BRACKET >}String analyzeTableAlias() #void :{  Token alias;}{  [ < K_AS > ] alias = < S_IDENTIFIER >  {    return alias.image;  }}void analyzeColumnName() #ColumnName :{  Token t;}{  (    t = < S_IDENTIFIER >  | t = "*"  | t = < S_P_IDENTIFIER : < IDENTIFIER > ".*" >  )  {    SqlColumn column = new SqlColumn(t.image, sqlPhase, sliceIndex);    jjtThis.jjtSetValue(column);    sqlMetadata.addColumn(column);  }}void analyzeFunctionDistinct() #FunctionDistinct :{}{  < K_DISTINCT >  (    analyzeColumnName()  |    (      < M_L_BRACKET > analyzeColumnName() < M_R_BRACKET >    )  )}void analyzeAlias() #Alias :{  Token alias;}{  [ < K_AS > ] alias = < S_IDENTIFIER >  {    jjtThis.jjtSetValue(alias.image);  }}void ananayzeValuePostion() #void :{}{  analyzeParameter()| analyzePlaceholder()| analyzeValue()| analyzeNumber()| analyzeBoolean()}void analyzeParameter() #Parameter :{}{  < M_QUERY >  {    jjtThis.jjtSetValue(globalParameterCount);    globalParameterCount++;  }}void analyzePlaceholder() #Placeholder :{  Token t;}{  < M_COLON > t = < S_IDENTIFIER >  {    jjtThis.jjtSetValue(t.image);  }}void analyzeValue() #Value :{  Token t;}{  t = < S_VALUE >  {    jjtThis.jjtSetValue(t.image);  }}void analyzeNumber() #Number :{  Token t;}{  t = < S_NUMBER >  {    jjtThis.jjtSetValue(t.image);  }}void analyzeBoolean() #Boolean :{  Token t;}{  (    t = < K_TRUE >  | t = < K_FALSE >  )  {    jjtThis.jjtSetValue(t.image);  }}